# 地址空间

地址空间是操作系统对物理内存的抽象，是运行的程序看到的系统中的内存。

一个进程的地址空间包含运行的程序的所有内存状态。比如：程序的代码（code，指令） 必须在内存中，因此它们在地址空间里。当程序在运行的时候，
利用栈（stack）来保存当 前的函数调用信息，分配空间给局部变量，传递参数和函数返回值。最后，堆（heap）用于管理动态分配的、用户管理的内存。


Q: 操作系统如何在单一的物理内存上为多个运行程序（所有进程共享内存）构建一个私有的，可能很大的地址空间抽象？

A: 虚拟化内存。应用程序拥有相同的起始地址(虚拟地址)，执行加载操作时，操作系统在硬件的支持下，加载到对应的物理地址，这是内存虚拟化的关键，这是
世界上每一个现代计算机系统的基础。

# 如何虚拟化内存

操作系统不仅虚拟化内存， 还有一定的风格。为了确保操作系统这样做，我们需要一些目标来指导。

虚拟内存（VM）系统的一个主要目标是透明（transparency）。操作系统实现虚拟内 存的方式，应该让运行的程序看不见。因此，程序不应该感知到内存被虚拟
化的事实，相反，程序的行为就好像它拥有自己的私有物理内存。在幕后，操作系统（和硬件）完成了所有的工作，让不同的工作复用内存，从而实现这个假象。

虚拟内存的另一个目标是效率（efficiency）。操作系统应该追求虚拟化尽可能高效 （efficient），包括时间上（即不会使程序运行得更慢）和空间
上（即不需要太多额外的内存来支持虚拟化）。在实现高效率虚拟化时，操作系统将不得不依靠硬件支持，包括 TLB 这样的硬件功能。

虚拟内存第三个目标是保护（protection）。操作系统应确保进程受到保护（protect）， 不会受其他进程影响，操作系统本身也不会受进程影响。当一个进程
执行加载、存储或指 令提取时，它不应该以任何方式访问或影响任何其他进程或操作系统本身的内存内容（即 在它的地址空间之外的任何内容）。因此，保护让
我们能够在进程之间提供隔离（isolation）的特性，每个进程都应该在自己的独立环境中运行，避免其他出错或恶意进程的影响。

# 虚拟内存

虚拟内存系统负责为程序提供一 个巨大的、稀疏的、私有的地址空间的假象，其中保存了程序的所有指令和数据。操作系统在专门硬件的帮助下，通过每一个虚拟
内存的索引，将其转换为物理地址，物理内存根据获得的物理地址但获取所需的信息。操作系统会同时对许多进程执行此操作，并且确保程序之间互相不会受到影响，
也不会影响操作系统。整个方法需要大量的机制（很多底层机制）和一些关键的策略。



为了实现高效的虚拟化，操作系统应该尽量让程序自己运行， 同时通过在关键点的及时介入（interposing），来保持对硬件的控制。高效和控制是现代操作系统
的两个主要目标。

在实现虚拟内存时，实现高效和控制的同时，提供期望的虚拟化。
1. 高效决定了我们要利用硬件的支持，这在开始的时候非常初级（如使用一些寄存器），但会变得相当复杂（比如我们会讲到的 TLB、页表等）
2. 控制意味着操作系统要确保应用程序只能访问它自己的内存空间
3. 要保护应用程序不会相互影响，也不会影响操作系统，我们需要硬件的帮助

最后，我们对虚拟内存还有一点要求，即灵活性。具体来说，我们希望程序能以任何方式访问它自己的地址空间，从而让系统更容易编程。

Q: 如何实现高效的内存虚拟化？如何提供应用程序所需的灵活性？如何保持控制应用程序可访问的内存位置，从而确保应用程序的内存访问受到合理的限制？
如何高效地实现这一切？

A: 基于硬件的地址转换（hardware-based address translation），简称为地址转换（address translation）

# 地址转换

硬件对每次内存访问进行处理（即指令获取、数据读取或写 入），将指令中的虚拟（virtual）地址转换为数据实际存储的物理（physical）地址。因此，
在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际的位置。

仅仅依靠硬件不足以实现虚拟内存，因为它只是提供了底层机制来提高效率。 操作系统必须在关键的位置介入，设置好硬件，以便完成正确的地址转换。因此它必
须管理内存（manage memory），记录被占用和空闲的内存位置，并明智而谨慎地介入，保持对内存使用的控制。

