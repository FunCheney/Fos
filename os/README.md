# 第四章 地址空间

## 如何实现

1. 操作系统能通过分页机制，把不同应用的相同虚拟地址映射到不同的物理地址中，这样写应用程序就不需要考虑应用的物理地址
布局的问题，能够以一种更加统一的方式编写应用程序，忽略掉一些不必要的细节。

2. 需要在内核中增加连续分配内存的能力
    
     2.1 操作系统如果要建立页表（构建虚实地址的映射关系），首先要能管理整个系统的物理内存。就需要知道整个计算机系统的
        物理内存范围，物理内存中那些区域是空闲可用的，那些区域放置内核/应用的代码和数据。
        
         操作系统内核能以物理页帧为单位分配和回收物理内存。

         操作系统内核能在虚拟内存中以各种粒度大小来动态分配内存资源。

     2.2 页表中的页表项索引其实是虚拟地址中的虚拟页号，页表项的重要内容是物理地址的物理页帧号。需要提供：物理地址、虚拟
        地址、物理页号、虚拟页号 之间可以相互转换的各种转换函数。

     2.3 完成了上述工作，基本上就做好了建立页表项的前期准备。就可以开始建立页表，主要涉及页表项的数据结构表示，以及多级页
        表的起始物理页帧地址和整个所占用的物理页帧的记录。

3. 一旦使能分页机制，CPU 访问到的地址都是虚拟地址，内核也将基于虚拟地址访问，所以在给应用添加虚拟地址空间之前，内核也会建
    立一个自己的页表，把整块物理内存通过简单的恒等映射（即虚拟地址映射到对等的物理地址）映射到内核虚拟地址空间中。
    后续的应用在执行前，也需要操作系统帮助它建立一个虚拟地址空间。这意味着第三章的初级 task 将进化到第四章的拥有独立页表的 task 。
    虚拟地址空间需要有一个数据结构管理起来，这就是 MemorySet ，即地址空间这个抽象概念所对应的具象体现。
    在一个虚拟地址空间中，有代码段，数据段等不同属性且不一定连续的子空间，它们通过一个重要的数据结构 MapArea 来表示和管理。

4. 完成到这里，我们就可以使能分页机制了。且我们应该有更加方便的机制来给支持应用运行。在本章之前，都是把应用程序的所有元数据丢弃从而转换
    成二进制格式来执行，这其实把编译器生成的 ELF 执行文件中大量有用的信息给去掉了，比如代码段、数据段的各种属性，程序的入口地址等。
    既然有了给应用运行提供虚拟地址空间的能力，我们就可以利用 ELF 执行文件中的各种信息来灵活构建应用运行所需要的虚拟地址空间。

5. 操作系统需要扩展任务控制块 TaskControlBlock 的管理范围，使得操作系统能管理拥有独立页表和单一虚拟地址空间的应用程序的运行。

6. 由于代表应用程序运行的任务和管理应用的操作系统各自有独立的页表和虚拟地址空间，所以在操作系统的设计实现上需要考虑两个挑战。

     第一个挑战是 页表切换 。由于系统调用、中断或异常导致的应用程序和操作系统之间的上下文切换不像以前那么简单了，因为在这些处理过程中需要切换页表。
     还有就是需要对来自用户态和内核态的异常/中断分别进行处理。
    
     第二个挑战是 查页表以访问不同地址空间的数据 。在内核地址空间中执行的内核代码常常需要读写应用的地址空间中的数据，这无法简单的通过一次访存来解决，
     而是需要手动查用户态应用的地址空间的页表，知道用户态应用的虚地址对应的物理地址后，转换成对应的内核态的虚地址，才能访问应用地址空间中的数据。
     如果访问应用地址空间中的数据跨了多个页，还需要注意处理地址的边界条件。

### Rust 中的内存分配

#### 静态与动态内存分配

