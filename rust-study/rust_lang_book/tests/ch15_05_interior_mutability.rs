/// 内部可变性 （Interior mutability）是 rust 的一种设计模式，它允许你在有不可变引用时也可以改变数据，这通常是借用规则不允许的。
/// 为了改变数据，该模式在数据结构中使用 unsafe 代码来模糊 Rust 通常的可变性和借用规则
/// 不安全代码表明，我们在手动检查这些规则，而不是让编译器帮我们检查

/// 当可以确保代码在运行时会遵守借用规则，即使编译器不能保证的情况，可以选择使用那些运用内部可变性模式的类型。
/// 所涉及的 unsafe 代码将被封装进安全的 API 中，而外部类型仍然是不可变的。

/// 通过 RefCell<T> 在运行时检查借用规则
/*
借用规则：
不同于 Rc<T>，RefCell<T> 代表其数据的唯一的所有权。那么是什么让 RefCell<T> 不同于像 Box<T> 这样的类型呢？
    1. 在任意给定时刻，只能拥有一个可变引用或任意数量的不可变引用 之一（而不是两者）。
    2. 引用必须总是有效的。
    对于引用和 Box<T>，借用规则的不可变性作用于 ⚠️ 编译时
    对于 RefCell<T>，这些不可变性作用于 ⚠️ 运行时

    在编译时检查借用规则的优势是这些错误将在开发过程的早期被捕获，同时对运行时没有性能影响，因为所有的分析都提前完成了。
    为此，在编译时检查借用规则是大部分情况的最佳选择，这也正是其为何是 Rust 的默认行为。
    相反在运行时检查借用规则的好处则是允许出现特定内存安全的场景，而它们在编译时检查中是不允许的。
*/

/// 如果 Rust 编译器不能通过所有权规则编译，它可能会拒绝一个正确的程序；从这种角度考虑它是保守的。
/// 如果 Rust 接受不正确的程序，那么用户也就不会相信 Rust 所做的保证了。
/// 然而，如果 Rust 拒绝正确的程序，虽然会给程序员带来不便，但不会带来灾难。
/// RefCell<T> 正是用于当你确信代码遵守借用规则，而编译器不能理解和确定的时候。

/// 如下为选择 Box<T>，Rc<T> 或 RefCell<T> 的理由：
///     Rc<T> 允许相同数据有多个所有者；Box<T> 和 RefCell<T> 有单一所有者。
///     Box<T> 允许在编译时执行不可变或可变借用检查；Rc<T>仅允许在编译时执行不可变借用检查；RefCell<T> 允许在运行时执行不可变或可变借用检查。
///     因为 RefCell<T> 允许在运行时执行可变借用检查，所以我们可以在即便 RefCell<T> 自身是不可变的情况下修改其内部的值。
///
/*
    RefCell<T> 是一个获得内部可变性的方法。RefCell<T> 并没有完全绕开借用规则，
    编译器中的借用检查器允许内部可变性并相应地在运行时检查借用规则。如果违反了这些规则，会出现 panic 而不是编译错误。
 */


