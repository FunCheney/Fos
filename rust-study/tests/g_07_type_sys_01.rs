/// 类型系统是一套规则集-- 把类型赋予和施加到编程语言上的元素
/// 这些元素可以是变量、函数和其他高阶结构。类型系统通过你在代码中提供的标注来给元素赋予类型，
/// 或者根据它的上下文隐式地推导某个元素的类型。类型系统允许在类型间做各种转换，同时禁止其他的一些转换。
/// 类型化的好处
/// 正确性、不可变性、封装性、组合性、可读性

#[test]
fn test_01() {
    let a = 1.0f32;
    //let b = 10;
    // 这里会报错：提示不能将一个整数与浮点数相乘
    // let c = a * b;
    // as 在做类型转换
    let b = 10 as f32;

    let c = a * b;
    println!("{}", c)
}
/// rust 非常明显的特点： 尽可能得显示化
/// 1. 不做隐式的类型转化
/// 2. 没有内置转化策略
#[test]
fn test_02() {
    let a = 9 + '1' as u8;
    let b = 9.to_string() + "1";
    println!("{}", a);
    println!("{}", b);
}

/// 用某种方式表示多种类型
/// 类型参数 T
struct Point<T> {
    x: T,
    y: T,
}

#[test]
fn test_03() {
    let integer = Point {x: 10, y: 20};
    let float = Point {x: 1.2, y: 3.2};
    // 如果是不同的类型
    // let p = Point {x:1, y:2.0};
}

struct Test<P, U>{
    x: P,
    y: U
}

#[test]
fn test_04() {
    let t1 = Test {x: 1, y: 2.0};
    let t2 = Test {x: 1.9, y: 2};
}

/// 可以用 turbofish 语法 ::<> 明确地给泛型，或者说是给 Rust 编译器提供类型参数信息
/// 类型参数存在两个过程，一个是定义时，一个是使用时
/// 这里所谓的“使用时”，仍然是在编译期进行分析的，也就是分析你在代码的某个地方用到了这个带类型参数的类型，
/// 然后把这个参数具体化，从而形成一个最终的类型版本。
/// 这种在编译期间完成的类型展开成具体版本的过程，被叫做编译期单态化。单态化的意思就是把处于混沌未知的状态具体化到一个单一的状态。
#[test]
fn test_05() {
    let p = Point::<i32>{x: 10, y: 30};
    let t = Test::<i32, f64>{x:10, y: 3.0};
}

/// 在泛型上做 impl
impl <T> Point<T>{ // 注意这一行
    // impl<T> Point<T> 中 的 Point<T> 中的 T 是使用类型参数 T，这个 T 是 impl 后面那个尖括号中的 T
    // struct Point<T> 中的 T 是定义参数类型 T
    fn play(n: T) {} // 注意这一行
}
/// 对泛型做了 impl 后，还可以对具体的类型 impl
impl Point<u32> {
    fn doit(){}
}

